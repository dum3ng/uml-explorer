{
"version":3,
"file":"module$node_modules$fast_xml_parser$src$xmlstr2xmlnode.js",
"lineCount":13,
"mappings":"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",
"sources":["node_modules/fast-xml-parser/src/xmlstr2xmlnode.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$fast_xml_parser$src$xmlstr2xmlnode\"] = function(global,require,module,exports) {\n'use strict';\n\nconst util = require('./util');\nconst buildOptions = require('./util').buildOptions;\nconst xmlNode = require('./xmlNode');\nconst regx =\n  '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]\u003e))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n  .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n  Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n  Number.parseFloat = window.parseFloat;\n}\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attrNodeName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  ignoreNameSpace: false,\n  allowBooleanAttributes: false, //a tag can have attributes without any value\n  //ignoreRootElement : false,\n  parseNodeValue: true,\n  parseAttributeValue: false,\n  arrayMode: false,\n  trimValues: true, //Trim string values of tag and attributes\n  cdataTagName: false,\n  cdataPositionChar: '\\\\c',\n  tagValueProcessor: function(a, tagName) {\n    return a;\n  },\n  attrValueProcessor: function(a, attrName) {\n    return a;\n  },\n  stopNodes: []\n  //decodeStrict: false,\n};\n\nexports.defaultOptions = defaultOptions;\n\nconst props = [\n  'attributeNamePrefix',\n  'attrNodeName',\n  'textNodeName',\n  'ignoreAttributes',\n  'ignoreNameSpace',\n  'allowBooleanAttributes',\n  'parseNodeValue',\n  'parseAttributeValue',\n  'arrayMode',\n  'trimValues',\n  'cdataTagName',\n  'cdataPositionChar',\n  'tagValueProcessor',\n  'attrValueProcessor',\n  'parseTrueNumberOnly',\n  'stopNodes'\n];\nexports.props = props;\n\n/**\n * Trim -> valueProcessor -> parse value\n * @param {string} tagName\n * @param {string} val\n * @param {object} options\n */\nfunction processTagValue(tagName, val, options) {\n  if (val) {\n    if (options.trimValues) {\n      val = val.trim();\n    }\n    val = options.tagValueProcessor(val, tagName);\n    val = parseValue(val, options.parseNodeValue, options.parseTrueNumberOnly);\n  }\n\n  return val;\n}\n\nfunction resolveNameSpace(tagname, options) {\n  if (options.ignoreNameSpace) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\nfunction parseValue(val, shouldParse, parseTrueNumberOnly) {\n  if (shouldParse && typeof val === 'string') {\n    let parsed;\n    if (val.trim() === '' || isNaN(val)) {\n      parsed = val === 'true' ? true : val === 'false' ? false : val;\n    } else {\n      if (val.indexOf('0x') !== -1) {\n        //support hexa decimal\n        parsed = Number.parseInt(val, 16);\n      } else if (val.indexOf('.') !== -1) {\n        parsed = Number.parseFloat(val);\n        val = val.replace(/\\.?0+$/, \"\");\n      } else {\n        parsed = Number.parseInt(val, 10);\n      }\n      if (parseTrueNumberOnly) {\n        parsed = String(parsed) === val ? parsed : val;\n      }\n    }\n    return parsed;\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])(.*?)\\\\3)?', 'g');\n\nfunction buildAttributesMap(attrStr, options) {\n  if (!options.ignoreAttributes && typeof attrStr === 'string') {\n    attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = resolveNameSpace(matches[i][1], options);\n      if (attrName.length) {\n        if (matches[i][4] !== undefined) {\n          if (options.trimValues) {\n            matches[i][4] = matches[i][4].trim();\n          }\n          matches[i][4] = options.attrValueProcessor(matches[i][4], attrName);\n          attrs[options.attributeNamePrefix + attrName] = parseValue(\n            matches[i][4],\n            options.parseAttributeValue,\n            options.parseTrueNumberOnly\n          );\n        } else if (options.allowBooleanAttributes) {\n          attrs[options.attributeNamePrefix + attrName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (options.attrNodeName) {\n      const attrCollection = {};\n      attrCollection[options.attrNodeName] = attrs;\n      return attrCollection;\n    }\n    return attrs;\n  }\n}\n\nconst getTraversalObj = function(xmlData, options) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\");\n  options = buildOptions(options, defaultOptions, props);\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n\n//function match(xmlData){\n  for(let i=0; i< xmlData.length; i++){\n    const ch = xmlData[i];\n    if(ch === '<'){\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        /* if (currentNode.parent) {\n          currentNode.parent.val = util.getValue(currentNode.parent.val) + '' + processTagValue2(tagName, textData , options);\n        } */\n        if(currentNode){\n          if(currentNode.val){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(tagName, textData , options);\n          }else{\n            currentNode.val = processTagValue(tagName, textData , options);\n          }\n        }\n\n        if (options.stopNodes.length && options.stopNodes.includes(currentNode.tagname)) {\n          currentNode.child = []\n          if (currentNode.attrsMap == undefined) { currentNode.attrsMap = {}}\n          currentNode.val = xmlData.substr(currentNode.startIndex + 1, i - currentNode.startIndex - 1)\n        }\n        currentNode = currentNode.parent;\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n        i = findClosingIndex(xmlData, \"?>\", i, \"Pi Tag is not closed.\")\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        i = findClosingIndex(xmlData, \"--\u003e\", i, \"Comment is not closed.\")\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"DOCTYPE is not closed.\")\n        const tagExp = xmlData.substring(i, closeIndex);\n        if(tagExp.indexOf(\"[\") >= 0){\n          i = xmlData.indexOf(\"]>\", i) + 1;\n        }else{\n          i = closeIndex;\n        }\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]\u003e\", i, \"CDATA is not closed.\") - 2\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        //considerations\n        //1. CDATA will always have parent node\n        //2. A tag with CDATA is not a leaf node so it's value would be string type.\n        if(textData){\n          currentNode.val = util.getValue(currentNode.val) + '' + processTagValue(currentNode.tagname, textData , options);\n          textData = \"\";\n        }\n\n        if (options.cdataTagName) {\n          //add cdata node\n          const childNode = new xmlNode(options.cdataTagName, currentNode, tagExp);\n          currentNode.addChild(childNode);\n          //for backtracking\n          currentNode.val = util.getValue(currentNode.val) + options.cdataPositionChar;\n          //add rest value to parent node\n          if (tagExp) {\n            childNode.val = tagExp;\n          }\n        } else {\n          currentNode.val = (currentNode.val || '') + (tagExp || '');\n        }\n\n        i = closeIndex + 2;\n      }else {//Opening tag\n        const result = closingIndexForOpeningTag(xmlData, i+1)\n        let tagExp = result.data;\n        const closeIndex = result.index;\n        const separatorIndex = tagExp.indexOf(\" \");\n        let tagName = tagExp;\n        let shouldBuildAttributesMap = true;\n        if(separatorIndex !== -1){\n          tagName = tagExp.substr(0, separatorIndex).replace(/\\s\\s*$/, '');\n          tagExp = tagExp.substr(separatorIndex + 1);\n        }\n\n        if(options.ignoreNameSpace){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n            shouldBuildAttributesMap = tagName !== result.data.substr(colonIndex + 1);\n          }\n        }\n\n        //save text to parent node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            currentNode.val = util.getValue(currentNode.val) + '' + processTagValue( currentNode.tagname, textData, options);\n          }\n        }\n\n        if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){//selfClosing tag\n\n          if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n            tagName = tagName.substr(0, tagName.length - 1);\n            tagExp = tagName;\n          }else{\n            tagExp = tagExp.substr(0, tagExp.length - 1);\n          }\n\n          const childNode = new xmlNode(tagName, currentNode, '');\n          if(tagName !== tagExp){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n        }else{//opening tag\n\n          const childNode = new xmlNode( tagName, currentNode );\n          if (options.stopNodes.length && options.stopNodes.includes(childNode.tagname)) {\n            childNode.startIndex=closeIndex;\n          }\n          if(tagName !== tagExp && shouldBuildAttributesMap){\n            childNode.attrsMap = buildAttributesMap(tagExp, options);\n          }\n          currentNode.addChild(childNode);\n          currentNode = childNode;\n        }\n        textData = \"\";\n        i = closeIndex;\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj;\n}\n\nfunction closingIndexForOpeningTag(data, i){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < data.length; index++) {\n    let ch = data[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === '>') {\n        return {\n          data: tagExp,\n          index: index\n        }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nexports.getTraversalObj = getTraversalObj;\n\n};"],
"names":["shadow$provide","global","require","module","exports","processTagValue","tagName","val","options","trimValues","trim","tagValueProcessor","parseValue","parseNodeValue","parseTrueNumberOnly","shouldParse","isNaN","parsed","indexOf","Number","parseInt","parseFloat","replace","String","util","isExist","buildAttributesMap","attrStr","ignoreAttributes","matches","getAllMatches","attrsRegx","len","length","attrs","i","ignoreNameSpace","tags","tagname","split","prefix","charAt","attrName","undefined","attrValueProcessor","attributeNamePrefix","parseAttributeValue","allowBooleanAttributes","Object","keys","attrNodeName","attrCollection","findClosingIndex","xmlData","str","errMsg","closingIndex","Error","buildOptions","xmlNode","nameRegexp","window","defaultOptions","textNodeName","arrayMode","cdataTagName","cdataPositionChar","a","stopNodes","props","getTraversalObj","xmlObj","currentNode","textData","ch","closeIndex","substring","colonIndex","substr","getValue","includes","child","attrsMap","startIndex","parent","tagExp","childNode","addChild","attrBoundary","index","data","result","separatorIndex","shouldBuildAttributesMap","lastIndexOf"]
}
