{
"version":3,
"file":"module$node_modules$fast_xml_parser$src$util.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/fast-xml-parser/src/util.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$fast_xml_parser$src$util\"] = function(global,require,module,exports) {\n'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.buildOptions = function(options, defaultOptions, props) {\n  var newOptions = {};\n  if (!options) {\n    return defaultOptions; //if there are not options\n  }\n\n  for (let i = 0; i < props.length; i++) {\n    if (options[props[i]] !== undefined) {\n      newOptions[props[i]] = options[props[i]];\n    } else {\n      newOptions[props[i]] = defaultOptions[props[i]];\n    }\n  }\n  return newOptions;\n};\n\n/**\n * Check if a tag name should be treated as array\n *\n * @param tagName the node tagname\n * @param arrayMode the array mode option\n * @param parentTagName the parent tag name\n * @returns {boolean} true if node should be parsed as array\n */\nexports.isTagNameInArrayMode = function (tagName, arrayMode, parentTagName) {\n  if (arrayMode === false) {\n    return false;\n  } else if (arrayMode instanceof RegExp) {\n    return arrayMode.test(tagName);\n  } else if (typeof arrayMode === 'function') {\n    return !!arrayMode(tagName, parentTagName);\n  }\n\n  return arrayMode === \"strict\";\n}\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n\n};"],
"names":["shadow$provide","global","require","module","exports","regexName","isExist","exports.isExist","v","isEmptyObject","exports.isEmptyObject","obj","Object","keys","length","merge","exports.merge","target","a","arrayMode","len","i","getValue","exports.getValue","buildOptions","exports.buildOptions","options","defaultOptions","props","newOptions","undefined","isTagNameInArrayMode","exports.isTagNameInArrayMode","tagName","parentTagName","RegExp","test","isName","string","match","exec","getAllMatches","regex","matches","allmatches","index","push","nameRegexp"]
}
