shadow$provide.module$node_modules$fast_xml_parser$src$validator=function(global,require,module,exports){function readPI(xmlData,i){for(var start=i;i<xmlData.length;i++)if("?"==xmlData[i]||" "==xmlData[i]){var tagname=xmlData.substr(start,i-start);if(5<i&&"xml"===tagname)return getErrorObject("InvalidXml","XML declaration allowed only at the start of the document.",getLineNumberForPosition(xmlData,i));if("?"==xmlData[i]&&"\x3e"==xmlData[i+1]){i++;break}}return i}function readCommentAndCDATA(xmlData,
i){if(xmlData.length>i+5&&"-"===xmlData[i+1]&&"-"===xmlData[i+2])for(i+=3;i<xmlData.length;i++){if("-"===xmlData[i]&&"-"===xmlData[i+1]&&"\x3e"===xmlData[i+2]){i+=2;break}}else if(xmlData.length>i+8&&"D"===xmlData[i+1]&&"O"===xmlData[i+2]&&"C"===xmlData[i+3]&&"T"===xmlData[i+4]&&"Y"===xmlData[i+5]&&"P"===xmlData[i+6]&&"E"===xmlData[i+7]){let angleBracketsCount=1;for(i+=8;i<xmlData.length;i++)if("\x3c"===xmlData[i])angleBracketsCount++;else if("\x3e"===xmlData[i]&&(angleBracketsCount--,0===angleBracketsCount))break}else if(xmlData.length>
i+9&&"["===xmlData[i+1]&&"C"===xmlData[i+2]&&"D"===xmlData[i+3]&&"A"===xmlData[i+4]&&"T"===xmlData[i+5]&&"A"===xmlData[i+6]&&"["===xmlData[i+7])for(i+=8;i<xmlData.length;i++)if("]"===xmlData[i]&&"]"===xmlData[i+1]&&"\x3e"===xmlData[i+2]){i+=2;break}return i}function validateAttributeString(attrStr,options){const matches=util.getAllMatches(attrStr,validAttrStrRegxp),attrNames={};for(let i=0;i<matches.length;i++){if(0===matches[i][1].length)return getErrorObject("InvalidAttr","Attribute '"+matches[i][2]+
"' has no space in starting.",getPositionFromMatch(attrStr,matches[i][0]));if(void 0===matches[i][3]&&!options.allowBooleanAttributes)return getErrorObject("InvalidAttr","boolean attribute '"+matches[i][2]+"' is not allowed.",getPositionFromMatch(attrStr,matches[i][0]));const attrName=matches[i][2];if(!util.isName(attrName))return getErrorObject("InvalidAttr","Attribute '"+attrName+"' is an invalid name.",getPositionFromMatch(attrStr,matches[i][0]));if(attrNames.hasOwnProperty(attrName))return getErrorObject("InvalidAttr",
"Attribute '"+attrName+"' is repeated.",getPositionFromMatch(attrStr,matches[i][0]));attrNames[attrName]=1}return!0}function validateAmpersand(xmlData,i){i++;if(";"===xmlData[i])return-1;if("#"===xmlData[i]){i++;a:{var re=/\d/;"x"===xmlData[i]&&(i++,re=/[\da-fA-F]/);for(;i<xmlData.length;i++){if(";"===xmlData[i]){xmlData=i;break a}if(!xmlData[i].match(re))break}xmlData=-1}return xmlData}for(re=0;i<xmlData.length;i++,re++)if(!(xmlData[i].match(/\w/)&&20>re)){if(";"===xmlData[i])break;return-1}return i}
function getErrorObject(code,message,lineNumber){return{err:{code,msg:message,line:lineNumber}}}function getLineNumberForPosition(xmlData,index){return xmlData.substring(0,index).split(/\r?\n/).length}function getPositionFromMatch(attrStr,match){return attrStr.indexOf(match)+match.length}const util=require("module$node_modules$fast_xml_parser$src$util"),defaultOptions={allowBooleanAttributes:!1},props=["allowBooleanAttributes"];exports.validate=function(xmlData,options){options=util.buildOptions(options,
defaultOptions,props);const tags=[];var tagFound=!1;let reachedRoot=!1;"ï»¿"===xmlData[0]&&(xmlData=xmlData.substr(1));for(let i=0;i<xmlData.length;i++)if("\x3c"===xmlData[i]&&"?"===xmlData[i+1]){if(i+=2,i=readPI(xmlData,i),i.err)return i}else if("\x3c"===xmlData[i])if(i++,"!"===xmlData[i])i=readCommentAndCDATA(xmlData,i);else{var closingTag=!1;"/"===xmlData[i]&&(closingTag=!0,i++);for(var tagName="";i<xmlData.length&&"\x3e"!==xmlData[i]&&" "!==xmlData[i]&&"\t"!==xmlData[i]&&"\n"!==xmlData[i]&&"\r"!==
xmlData[i];i++)tagName+=xmlData[i];tagName=tagName.trim();"/"===tagName[tagName.length-1]&&(tagName=tagName.substring(0,tagName.length-1),i--);if(!util.isName(tagName))return options=0===tagName.trim().length?"There is an unnecessary space between tag name and backward slash '\x3c/ ..'.":"Tag '"+tagName+"' is an invalid name.",getErrorObject("InvalidTag",options,getLineNumberForPosition(xmlData,i));{var JSCompiler_inline_result=i;var attrStr="";let startChar="",tagClosed=!1;for(;JSCompiler_inline_result<
xmlData.length;JSCompiler_inline_result++){if(xmlData[JSCompiler_inline_result]===doubleQuote||xmlData[JSCompiler_inline_result]===singleQuote)if(""===startChar)startChar=xmlData[JSCompiler_inline_result];else if(startChar!==xmlData[JSCompiler_inline_result])continue;else startChar="";else if("\x3e"===xmlData[JSCompiler_inline_result]&&""===startChar){tagClosed=!0;break}attrStr+=xmlData[JSCompiler_inline_result]}JSCompiler_inline_result=""!==startChar?!1:{value:attrStr,index:JSCompiler_inline_result,
tagClosed}}attrStr=JSCompiler_inline_result;if(!1===attrStr)return getErrorObject("InvalidAttr","Attributes for '"+tagName+"' have open quote.",getLineNumberForPosition(xmlData,i));JSCompiler_inline_result=attrStr.value;i=attrStr.index;if("/"===JSCompiler_inline_result[JSCompiler_inline_result.length-1])if(JSCompiler_inline_result=JSCompiler_inline_result.substring(0,JSCompiler_inline_result.length-1),tagFound=validateAttributeString(JSCompiler_inline_result,options),!0===tagFound)tagFound=!0;else return getErrorObject(tagFound.err.code,
tagFound.err.msg,getLineNumberForPosition(xmlData,i-JSCompiler_inline_result.length+tagFound.err.line));else if(closingTag)if(attrStr.tagClosed){if(0<JSCompiler_inline_result.trim().length)return getErrorObject("InvalidTag","Closing tag '"+tagName+"' can't have attributes or invalid starting.",getLineNumberForPosition(xmlData,i));closingTag=tags.pop();if(tagName!==closingTag)return getErrorObject("InvalidTag","Closing tag '"+closingTag+"' is expected inplace of '"+tagName+"'.",getLineNumberForPosition(xmlData,
i));0==tags.length&&(reachedRoot=!0)}else return getErrorObject("InvalidTag","Closing tag '"+tagName+"' doesn't have proper closing.",getLineNumberForPosition(xmlData,i));else{tagFound=validateAttributeString(JSCompiler_inline_result,options);if(!0!==tagFound)return getErrorObject(tagFound.err.code,tagFound.err.msg,getLineNumberForPosition(xmlData,i-JSCompiler_inline_result.length+tagFound.err.line));if(!0===reachedRoot)return getErrorObject("InvalidXml","Multiple possible root nodes found.",getLineNumberForPosition(xmlData,
i));tags.push(tagName);tagFound=!0}for(i++;i<xmlData.length;i++)if("\x3c"===xmlData[i])if("!"===xmlData[i+1])i++,i=readCommentAndCDATA(xmlData,i);else if("?"===xmlData[i+1]){if(i=readPI(xmlData,++i),i.err)return i}else break;else if("\x26"===xmlData[i]){tagName=validateAmpersand(xmlData,i);if(-1==tagName)return getErrorObject("InvalidChar","char '\x26' is not expected.",getLineNumberForPosition(xmlData,i));i=tagName}"\x3c"===xmlData[i]&&i--}else if(" "!==xmlData[i]&&"\t"!==xmlData[i]&&"\n"!==xmlData[i]&&
"\r"!==xmlData[i])return getErrorObject("InvalidChar","char '"+xmlData[i]+"' is not expected.",getLineNumberForPosition(xmlData,i));return tagFound?0<tags.length?getErrorObject("InvalidXml","Invalid '"+JSON.stringify(tags,null,4).replace(/\r?\n/g,"")+"' found.",1):!0:getErrorObject("InvalidXml","Start tag expected.",1)};var doubleQuote='"',singleQuote="'";const validAttrStrRegxp=/(\s*)([^\s=]+)(\s*=)?(\s*(['"])(([\s\S])*?)\5)?/g}
//# sourceMappingURL=module$node_modules$fast_xml_parser$src$validator.js.map
